import { EventEmitter } from 'events';
import {
  DiagnosticError,
  InvalidStateError,
  PromiseTimedOutError,
} from '../errors';
import {
  NetworkInformation,
  networkInformationPolyfill as networkInformation,
} from '../polyfills/NetworkInformation';
import { NetworkTiming, TimeMeasurement } from '../timing';
import { validateOptions, validateTime } from '../utils/OptionValidation';
import { waitForPromise } from '../utils/TimeoutPromise';
import { TestCall } from './TestCall';

export declare interface NetworkTest {
  /**
   * This event is emitted when the test ends. Emits a [[NetworkTest.Report]]
   * summarizing the run time of the test.
   * @param event [[NetworkTest.Events.End]]
   * @param report The report summarizing the run time of the test.
   * @private
   */
  emit(
    event: NetworkTest.Events.End,
    report: NetworkTest.Report,
  ): boolean;
  /**
   * This event is emitted when the test encounters an error, fatal or not.
   * Emits the [[DiagnosticError]] encountered.
   * @param event [[NetworkTest.Events.Error]]
   * @param error The [[DiagnosticError]] encountered, fatal or not.
   * @private
   */
  emit(
    event: NetworkTest.Events.Error,
    error: DiagnosticError,
  ): boolean;

  /**
   * Raised upon completion of the test.
   * @param event [[NetworkTest.Events.End]]
   * @param listener A callback with a [[NetworkTest.Report]] parameter.
   * @returns This [[NetworkTest]] instance.
   * @event
   */
  on(
    event: NetworkTest.Events.End,
    listener: (report: NetworkTest.Report,
  ) => any): this;
  /**
   * Raised when the test encounters an error.
   * @param event [[NetworkTest.Events.Error]]
   * @param listener A callback with a [[DiagnosticError]] parameter.
   * @returns This [[NetworkTest]] instance.
   * @event
   */
  on(
    event: NetworkTest.Events.Error,
    listener: (error: DiagnosticError) => any,
  ): this;
}

/**
 * Runs network connectivity tests while connected to Twilio.
 * This can be used to test connectivity to different regions using either UDP or TCP protocol.
 * Region and protocol can be specified using [[NetworkTest.Options.iceServers]] option.
 */
export class NetworkTest extends EventEmitter {
  /**
   * The test message that is sent from one end of the [[TestCall]] to the
   * other to determine connectivity through WebRTC.
   * @private
   */
  static testMessage: string = 'Ahoy, world!';
  /**
   * The name of the test.
   */
  static testName: 'network-connectivity' = 'network-connectivity';
  /**
   * Default options for the [[NetworkTest]]. These will be overwritten by any
   * option passed in the [[NetworkTest.constructor]] `options` parameter.
   */
  private static defaultOptions: NetworkTest.DefaultOptions = {
    networkInformation,
    timeoutMs: 5000,
  };

  /**
   * When the test ends, generated by a call to `Date.now` as soon as
   * [[NetworkTest._stop]] is called internally.
   */
  private _endTime: number | null = null;
  /**
   * Any errors that the [[NetworkTest]] encounters during its run time.
   */
  private _errors: DiagnosticError[] = [];
  /**
   * Network event time measurements.
   */
  private _networkTiming: NetworkTiming = {};
  /**
   * Options that have been passed to the [[NetworkTest]].
   */
  private _options: NetworkTest.Options;
  /**
   * The configuration to pass to [[TestCall]].
   */
  private _peerConnectionConfig: RTCConfiguration;
  /**
   * When the test starts, set on construction.
   */
  private _startTime: number;
  /**
   * The [[TestCall]] used internally.
   */
  private _testCall: TestCall | null = null;

  /**
   * Initializes the test and starts it.
   * @param options Options to pass to the constructor.
   */
  constructor(options: NetworkTest.Options) {
    super();

    this._options = { ...NetworkTest.defaultOptions, ...options };

    this._startTime = Date.now();
    this._peerConnectionConfig = {
      iceServers: this._options.iceServers,
    };

    setTimeout(() => this._startTest());
  }

  /**
   * Determine if the test has passed or not.
   */
  private _determinePass(): boolean {
    return this._errors.length === 0;
  }

  /**
   * Adds the error to the internal list of errors that have occured, which will
   * be included in the final test report.
   * @param error
   */
  private _onError(error: DiagnosticError): void {
    this._errors.push(error);
    this.emit(NetworkTest.Events.Error, error);
  }

  /**
   * Starts the test by connecting the two [[RTCPeerConnection]] ends of the
   * [[TestCall]] and then attempting to send a message from one end to the
   * other. If this process takes
   */
  private async _startTest(): Promise<void> {
    try {
      await validateOptions(this._options, { timeoutMs: validateTime });

      this._testCall = new TestCall({
        peerConnectionConfig: this._peerConnectionConfig,
        peerConnectionFactory: this._options.peerConnectionFactory,
        timeoutDuration: this._options.timeoutMs!,
      });

      // Set up a promise that resolves when we receive the correct message
      // on the receiving PeerConnection
      const waitReceivedMessage: Promise<void> = new Promise(
        (resolve: () => void, reject: (error: InvalidStateError) => void): void => {
          if (!this._testCall) {
            reject(new InvalidStateError('TestCall is `null`.'));
            return;
          }
          this._testCall.on(TestCall.Event.Message, (message: MessageEvent) => {
            if (message.data === NetworkTest.testMessage) {
              this._networkTiming.firstPacket = Date.now();
              resolve();
            }
          });
        },
      );

      // We race between two promises:
      // an async function that will resolve once we connect and we send and
      // receive a message,
      // and
      // the timeout promise signifying the test has timed out.

      // If an error occurs during the runtime of the async function, i.e.
      // while we are establishing a connection, sending a message, or waiting
      // for the message to be recieved, this rejection is forwarded to the
      // [[_onError]] handler of the NetworkTest.
      try {
        await waitForPromise((async (): Promise<void> => {
          if (!this._testCall) {
            throw new InvalidStateError('TestCall is `null`.');
          }
          await this._testCall.establishConnection();
          this._testCall.send(NetworkTest.testMessage);
          await waitReceivedMessage;
        })(), this._options.timeoutMs!);
      } catch (error) {
        if (error instanceof PromiseTimedOutError) {
          throw new DiagnosticError(
            undefined,
            'NetworkTest timeout, the PeerConnection did not receive the ' +
            'message.',
          );
        } else {
          // Re-throw the error so the handler at the end of `_startTest`
          // can handle it properly.
          throw error;
        }
      }

      // If none of the Promises reject, then we successfully received the
      // `testMessage`.
      this._stop(true);
    } catch (error) {
      if (error instanceof DiagnosticError) {
        this._onError(error);
      } else if (
        typeof DOMException !== 'undefined' && error instanceof DOMException
      ) {
        // Could be thrown by the PeerConnections during the call
        // `testCall.establishConnection`.
        this._onError(new DiagnosticError(
          error,
          'A `DOMException` occurred.',
        ));
      } else if (
        typeof DOMError !== 'undefined' && error instanceof DOMError
      ) {
        this._onError(new DiagnosticError(
          error,
          'A `DOMError` occurred.',
        ));
      } else {
        // An unknown error occurred.
        this._onError(error);
      }
      this._stop(false);
    }
  }

  /**
   * Stop the `NetworkTest`. This performs cleanup on the [[TestCall]] and
   * emits a report for the test.
   * @param didPass Override the check. Useful when encountering a fatal error.
   */
  private _stop(didPass: boolean = true): void {
    if (this._testCall) {
      this._testCall.close();
    }

    // Use the network information polyfill, if the info is `undefined` then
    // use an empty object so all members will be `undefined`.
    const info: NetworkInformation = this._options.networkInformation || {};

    this._endTime = Date.now();

    const testCallNetworkTiming: NetworkTiming = this._testCall
      ? this._testCall.getNetworkTiming()
      : {};

    // We are unable to use the spread operator here on `networkInformation`,
    // the values will always be `undefined`.
    const report: NetworkTest.Report = {
      didPass: didPass && this._determinePass(),
      downlink: info.downlink,
      downlinkMax: info.downlinkMax,
      effectiveType: info.effectiveType,
      errors: this._errors,
      networkTiming: { ...this._networkTiming, ...testCallNetworkTiming },
      rtt: info.rtt,
      saveData: info.saveData,
      testName: NetworkTest.testName,
      testTiming: {
        duration: this._endTime - this._startTime,
        end: this._endTime,
        start: this._startTime,
      },
      type: info.type,
    };

    this.emit(NetworkTest.Events.End, report);
  }
}

export namespace NetworkTest {
  /**
   * Default options for [[NetworkTest]]
   * @private
   */
  export type DefaultOptions = Pick<Options, 'networkInformation' | 'timeoutMs'>;

  /**
   * Possible options for the [[NetworkTest]].
   */
  export interface Options {
    /**
     * The array of [RTCIceServer](https://developer.mozilla.org/en-US/docs/Web/API/RTCIceServer) configurations to use.
     * You need to provide TURN server configurations to ensure that your network connectivity is tested.
     * See [Twilio's Network Traversal Service](https://www.twilio.com/stun-turn) to get TURN credentials and for specifying a region or protocol.
     */
    iceServers: RTCIceServer[];

    /**
     * A `NetworkInformation` connection. Used for mocking.
     * @private
     */
    networkInformation?: NetworkInformation;

    /**
     * A `PeerConnection` factory to be used, mainly for Mocking.
     * @private
     */
    peerConnectionFactory?: typeof RTCPeerConnection;

    /**
     * Timeout in milliseconds. This causes a [[DiagnosticError]] if the test is
     * unable to connect to the server.
     * @default 5000
     */
    timeoutMs?: number;
  }
  /**
   * Possible events that an `NetworkTest` might emit. See [[NetworkTest.on]].
   */
  export enum Events {
    End = 'end',
    Error = 'error',
  }
  /**
   * Represents the report generated from a [[NetworkTest]].
   */
  export interface Report {
    /**
     * Whether or not the test passed. This is `false` if there are errors that occurred during the test.
     */
    didPass: boolean;
    /**
     * The effective bandwidth estimate in megabits per second, rounded to the nearest multiple of 25 kilobits per seconds.
     * Please see [NetworkInformation.downlink API](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/downlink).
     */
    downlink?: number;
    /**
     * The maximum downlink speed, in megabits per second (Mbps), for the underlying connection technology.
     * Please see [NetworkInformation.downlinkMax API](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/downlinkMax).
     */
    downlinkMax?: number;
    /**
     * The effective type of the connection meaning one of 'slow-2g', '2g', '3g', or '4g'.
     * Please see [NetworkInformation.effectiveType API](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType).
     */
    effectiveType?: string;
    /**
     * Any errors that occurred during the test.
     */
    errors: DiagnosticError[];
    /**
     * Network related time measurements.
     */
    networkTiming: NetworkTiming;
    /**
     * The estimated effective round-trip time of the current connection, rounded to the nearest multiple of 25 milliseconds.
     * Please see [NetworkInformation.rtt API](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/rtt).
     */
    rtt?: number;
    /**
     * Returns `true` if the user has set a reduced data usage option on the user agent.
     * Please see [NetworkInformation.saveData API](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/saveData).
     */
    saveData?: boolean;
    /**
     * The name of the test.
     */
    testName: typeof NetworkTest.testName;
    /**
     * Time measurements of test run time.
     */
    testTiming: TimeMeasurement;
    /**
     * The type of connection a device is using to communicate with the network.
     * Please see [NetworkInformation.type API](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/type).
     */
    type?: string;
  }
}

/**
 * Test network connectivity to Twilio
 * @param options
 */
export function testNetwork(
  options: NetworkTest.Options,
): NetworkTest {
  return new NetworkTest(options);
}
