{"version":3,"file":"optionValidation.js","sourceRoot":"","sources":["../../../lib/utils/optionValidation.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  enumerateDevices,\n  EnumerateDevicesUnsupportedError,\n} from '../polyfills';\n\n/**\n * @internalapi\n * Helper type that defines the type of the options we expect.\n */\nexport type InputOptions = Record<string, any>;\n\n/**\n * @internalapi\n * Helper type for what a [[ValidatorFunction]] should return;\n */\nexport type Validity = string | undefined;\n\n/**\n * @internalapi\n * Helper type for validation. All validators should have this typing.\n * If the option is invalid, then the validator should return a string\n * describing why, otherwise return nothing or `undefined`.\n */\nexport type ValidatorFunction = (option: any) => Validity | Promise<Validity>;\n\n/**\n * @internalapi\n * Helper type for validation. Defines the configuration that `validateOptions`\n * expects.\n */\nexport type ValidatorConfig<T extends InputOptions> = Partial<Record<\n  keyof T,\n  ValidatorFunction | ValidatorFunction[] | undefined\n>>;\n\n/**\n * @internalapi\n * Helper type for validation. Defines the record that describes the invalidity\n * of options if they are found invalid.\n */\nexport type InvalidityRecord<T extends InputOptions> = Partial<Record<\n  keyof T,\n  string[]\n>>;\n\n/**\n * @internalapi\n * Helper type for audio device validation.\n */\ninterface AudioDeviceValidatorOptions {\n  enumerateDevices?: typeof navigator.mediaDevices.enumerateDevices;\n  kind?: MediaDeviceKind;\n}\n\n/**\n * @internalapi\n * Return a function that validates an audio device by ID. It will returns a\n * `string` representing why the ID is invalid, or nothing if it is valid. Will\n * throw if `enumerateDevices` is not supported by the system.\n * @param options Options to pass to the validator. A mock `enumerateDevices`\n * may be passed here, as well as a `kind` may be passed here if there is a\n * desire to check the `kind` of audio device.\n * @returns A function that takes a `string` representing the audio device ID to\n * be validated and returns a Promise resolving a `string` representing the\n * invalid message or `undefined` if the audio device is valid.\n */\nexport function createAudioDeviceValidator(\n  options: AudioDeviceValidatorOptions = {},\n): ValidatorFunction {\n  const opts: AudioDeviceValidatorOptions = { enumerateDevices, ...options };\n\n  /**\n   * The audio device validator that will be returned.\n   * @param deviceId The device ID to be validated.\n   * @returns A Promise that resolves with a `string` representing why the\n   * device ID is invalid, or `undefined` if it is valid.\n   */\n  return async (deviceId: string | undefined): Promise<Validity> => {\n    const devices: MediaDeviceInfo[] | undefined =\n      opts.enumerateDevices && await opts.enumerateDevices();\n\n    if (!devices) {\n      throw EnumerateDevicesUnsupportedError;\n    }\n\n    if (!devices.length) {\n      return 'No audio devices available.';\n    }\n\n    // `deviceId` as `undefined` is a valid value as this will cause\n    // `getUserMedia` to just get the default device\n    if (deviceId === undefined) {\n      if (opts.kind) {\n        // If we get here, we just want to make sure there is at least one\n        // media device with the correct kind.\n        const matchingDevicesKind = devices.filter((device: MediaDeviceInfo) =>\n          device.kind === opts.kind);\n\n        if (!matchingDevicesKind.length) {\n          return `No devices found with the correct kind \"${opts.kind}\".`;\n        }\n      }\n      return;\n    }\n\n    const matchingDevicesId = devices.filter((device: MediaDeviceInfo) =>\n      device.deviceId === deviceId);\n\n    if (!matchingDevicesId.length) {\n      return `Device ID \"${deviceId}\" not found within list of available devices.`;\n    }\n\n    if (opts.kind) {\n      const matchingDevicesIdAndKind = matchingDevicesId.filter(\n        (device: MediaDeviceInfo) => device.kind === opts.kind);\n      if (!matchingDevicesIdAndKind.length) {\n        return `Device ID \"${deviceId}\" is not the correct \"kind\",`\n          + ` expected \"${opts.kind}\".`;\n      }\n    }\n  };\n}\n\n/**\n * @internalapi\n * Validate that an option is a valid device ID to pass to `getUserMedia` or\n * `setSinkId`.\n * @param option The option to check is a valid device ID to pass to\n * `getUserMedia` or `setSinkId`.\n * @returns If the option is not valid, return a string that describes why,\n * otherwise `undefined`.\n */\nexport function validateDeviceId(option: any): Validity {\n  if (!(['string', 'undefined'].includes(typeof option) || option === null)) {\n    return 'If \"deviceId\" is defined, it must be a \"string\".';\n  }\n}\n\n/**\n * @internalapi\n * Validate that an option is a valid string.\n * @param option The option to check is a valid string.\n * @returns If the option is not valid, return a string that describes why it is\n * invalid, otherwise return `undefined`.\n */\nexport function validateString(option: any): Validity {\n  const type = typeof option;\n  if (type !== 'string') {\n    return `Option cannot have type \"${type}\", must be \"string\".`;\n  }\n}\n\n/**\n * @internalapi\n * Validate a time-based parameter, i.e. duration or interval.\n * @param option The duration of time to validate\n * @returns A possibly undefined string, if the time is valid it will return\n * undefined, otherwise an error message\n */\nexport function validateTime(option: any): Validity {\n  const doesNotExistMessage = validateExists(option);\n  if (doesNotExistMessage) {\n    return doesNotExistMessage;\n  }\n\n  if (typeof option !== 'number') {\n    return 'Time must be a number.';\n  }\n\n  if (option < 0) {\n    return 'Time must always be non-negative.';\n  }\n}\n\n/**\n * @internalapi\n * Validate that an option is neither `undefined` nor `null`.\n * @param option The option to check exists.\n * @returns A possibly undefined string, if the option exists it will return\n * `undefined`, otherwise a string representing why the option is invalid\n */\nexport function validateExists(option: any): Validity {\n  if (option === undefined || option === null) {\n    return `Option cannot be \"${String(option)}\".`;\n  }\n}\n\n/**\n * @internalapi\n * Validate that an option is a `boolean`.\n * @param option The option to check.\n * @returns A possibly undefined string, if the option is valid it will return\n * `undefined`, otherwise a string representing why the option is invalid\n */\nexport function validateBoolean(option: any): Validity {\n  if (typeof option !== 'boolean') {\n    return `Option must be \"boolean\".`;\n  }\n}\n\n/**\n * @internalapi\n * Validate input options to the [[InputTest]].\n * @param inputOptions The options to validate.\n * @param config A record of option names to either a single\n * [[ValidatorFunction]] or an array of [[ValidatorFunctions]].\n * @returns A Promise that resolves either with a [[InvalidityRecord]] describing\n * which options are invalid and why, or `undefined` if all options are vaild.\n */\nexport async function validateOptions<T extends InputOptions>(\n  inputOptions: T,\n  config: ValidatorConfig<T>,\n): Promise<InvalidityRecord<T> | undefined> {\n  // Create a validity record to return once all the validators finish running.\n  const validity: InvalidityRecord<T> = {};\n\n  await Promise.all(Object.entries(config).map(async ([\n    optionKey,\n    validatorFunctions,\n  ]: [\n    keyof T,\n    ValidatorFunction | ValidatorFunction[] | undefined,\n  ]): Promise<void> => {\n    if (!validatorFunctions) {\n      return;\n    }\n\n    const optionValue = inputOptions[optionKey];\n\n    const validators = Array.isArray(validatorFunctions)\n      ? validatorFunctions\n      : [validatorFunctions];\n\n    await Promise.all(validators.map(\n      async (validator: ValidatorFunction): Promise<void> => {\n        const invalidReason = await validator(optionValue);\n        if (invalidReason) {\n          const invalidReasons: string[] | undefined = validity[optionKey];\n          if (invalidReasons) {\n            invalidReasons.push(invalidReason);\n          } else {\n            validity[optionKey] = [invalidReason];\n          }\n        }\n      },\n    ));\n  }));\n\n  if (Object.keys(validity).length) {\n    return validity;\n  }\n}\n"]}