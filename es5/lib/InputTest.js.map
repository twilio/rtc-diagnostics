{"version":3,"file":"InputTest.js","sourceRoot":"","sources":["../../lib/InputTest.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport { TestNames } from './constants';\nimport {\n  AlreadyStoppedError,\n  DiagnosticError,\n  InvalidOptionsError,\n} from './errors';\nimport {\n  AudioContext,\n  AudioContextUnsupportedError,\n  enumerateDevices,\n  EnumerateDevicesUnsupportedError,\n  getDefaultDevices,\n  getUserMedia,\n  GetUserMediaUnsupportedError,\n} from './polyfills';\nimport { SubsetRequired, TimeMeasurement } from './types';\nimport { detectSilence } from './utils';\nimport {\n  InvalidityRecord,\n  validateDeviceId,\n  validateOptions,\n  validateTime,\n} from './utils/optionValidation';\n\nexport declare interface InputTest {\n  /**\n   * This event is emitted with a boolean representing if the test passed and a\n   * test report when the test ends.\n   * @param event [[InputTest.Events.End]]\n   * @param report Summary of the test.\n   * @private\n   */\n  emit(\n    event: InputTest.Events.End,\n    report: InputTest.Report,\n  ): boolean;\n  /**\n   * This event is emitted with a [[DiagnosticError]] when the test encounters\n   * an error, fatal or not.\n   * @param event [[InputTest.Events.Error]]\n   * @param error The [[DiagnosticError]] that was encountered.\n   * @private\n   */\n  emit(\n    event: InputTest.Events.Error,\n    error: DiagnosticError,\n  ): boolean;\n  /**\n   * This event is emitted with a volume level every\n   * [[InputTest.Options.volumeEventIntervalMs]] after the test starts succesfully.\n   * @param event [[InputTest.Events.Volume]]\n   * @param value The current volume of the audio source.\n   * @private\n   */\n  emit(\n    event: InputTest.Events.Volume,\n    value: number,\n  ): boolean;\n\n  /**\n   * Raised upon completion of the test.\n   * @param event [[InputTest.Events.End]]\n   * @param listener A callback that expects the following parameters:\n   *  An [[InputTest.Report]] that summarizes the test.\n   * @returns This [[InputTest]] instance.\n   * @event\n   */\n  on(\n    event: InputTest.Events.End,\n    listener: (report: InputTest.Report) => any,\n  ): this;\n  /**\n   * Raised by the test when encountering an error with a parameter of type\n   * [[DiagnosticError]].\n   * @param event [[InputTest.Events.Error]]\n   * @param listener A callback that expects the following parameters:\n   *  A [[DiagnosticError]] that the test encountered.\n   * @returns This [[InputTest]] instance.\n   * @event\n   */\n  on(\n    event: InputTest.Events.Error,\n    listener: (error: DiagnosticError) => any,\n  ): this;\n  /**\n   * Raised by the test every [[Options.volumeEventIntervalMs]] amount of\n   * milliseconds with a parameter of type `number` that represents the\n   * current volume of the audio stream.\n   * @param event [[InputTest.Events.Volume]]\n   * @param listener A callback that expects the following parameters:\n   *  A `number` that represents the audio source's current volume.\n   * @returns This [[InputTest]] instance.\n   * @event\n   */\n  on(\n    event: InputTest.Events.Volume,\n    listener: (value: number) => any,\n  ): this;\n}\n\n/**\n * [[InputTest]] class that parses options and starts an audio input device\n * test.\n *\n * Please see [[testInputDevice]] for details and recommended practices.\n */\nexport class InputTest extends EventEmitter {\n  /**\n   * Name of the test.\n   */\n  static testName: TestNames.InputAudioDevice = TestNames.InputAudioDevice;\n\n  /**\n   * Default options for the `InputTest`.\n   */\n  private static defaultOptions: InputTest.InternalOptions = {\n    audioContextFactory: AudioContext,\n    debug: false,\n    duration: Infinity,\n    enumerateDevices,\n    getUserMedia,\n    volumeEventIntervalMs: 100,\n  };\n\n  /**\n   * An `AudioContext` to use for generating volume levels.\n   */\n  private _audioContext: AudioContext | null = null;\n  /**\n   * A function that will be assigned in `_startTest` that when run will clean\n   * up the audio nodes created in the same function.\n   */\n  private _cleanupAudio: (() => void) | null = null;\n  /**\n   * The default media devices when starting the test.\n   */\n  private _defaultDevices: Partial<Record<\n    MediaDeviceKind,\n    MediaDeviceInfo\n  >> = {};\n  /**\n   * A timestamp that is set when the test ends.\n   */\n  private _endTime: number | null = null;\n  /**\n   * An array of any errors that occur during the run time of the test.\n   */\n  private readonly _errors: DiagnosticError[] = [];\n  /**\n   * The maximum volume level from the audio source.\n   */\n  private _maxValue: number = 0;\n  /**\n   * A `MediaStream` that is created from the input device.\n   */\n  private _mediaStream: MediaStream | null = null;\n  /**\n   * Options that are passed to and set in the constructor for use during the\n   * test.\n   */\n  private _options: InputTest.InternalOptions;\n  /**\n   * A timestamp that is set when the test starts after a successful call to getUserMedia.\n   */\n  private _startTime: number | undefined;\n  /**\n   * Volume levels generated from the audio source during the run time of the\n   * test.\n   */\n  private readonly _values: number[] = [];\n  /**\n   * The timeout that causes the volume event to loop; created by `setTimeout`.\n   */\n  private _volumeTimeout: NodeJS.Timeout | null = null;\n\n  /**\n   * Initializes the `startTime` and `options`.\n   * @param options Optional settings to pass to the test.\n   */\n  constructor(options?: InputTest.Options) {\n    super();\n\n    this._options = { ...InputTest.defaultOptions, ...options };\n\n    // We need to use a `setTimeout` here to prevent a race condition.\n    // This allows event listeners to bind before the test starts.\n    setTimeout(() => this._startTest());\n  }\n\n  /**\n   * Stop the currently running `InputTest`.\n   * @param pass whether or not the test should pass. If set to false, will\n   * override the result from determining whether audio is silent from the collected volume levels.\n   */\n  stop(pass: boolean = true): InputTest.Report | undefined {\n    if (this._endTime) {\n      this._onWarning(new AlreadyStoppedError());\n      return;\n    }\n\n    // Perform cleanup\n    this._cleanup();\n\n    this._endTime = Date.now();\n    const didPass: boolean = pass && !detectSilence(this._values);\n    const report: InputTest.Report = {\n      deviceId: this._options.deviceId || (\n        this._defaultDevices.audioinput &&\n        this._defaultDevices.audioinput.deviceId\n      ),\n      didPass,\n      errors: this._errors,\n      testName: InputTest.testName,\n      values: this._values,\n    };\n\n    if (this._startTime) {\n      report.testTiming = {\n        duration: this._endTime - this._startTime,\n        end: this._endTime,\n        start: this._startTime,\n      };\n    }\n\n    this.emit(InputTest.Events.End, report);\n\n    return report;\n  }\n\n  /**\n   * Clean up any instantiated objects (i.e. `AudioContext`, `MediaStreams`,\n   * etc.).\n   * Called by `.stop`.\n   */\n  private _cleanup(): void {\n    if (this._volumeTimeout) {\n      clearTimeout(this._volumeTimeout);\n    }\n    if (this._cleanupAudio) {\n      this._cleanupAudio();\n    }\n    if (this._mediaStream) {\n      this._mediaStream.getTracks().forEach(\n        (track: MediaStreamTrack) => track.stop(),\n      );\n    }\n    if (this._audioContext) {\n      this._audioContext.close();\n    }\n  }\n\n  /**\n   * Helper function that should be called when an error occurs, recoverable\n   * or not.\n   * @param error\n   */\n  private _onError(error: DiagnosticError): void {\n    this._errors.push(error);\n    this.emit(InputTest.Events.Error, error);\n  }\n\n  /**\n   * Called every `InputTest._options.volumeEventIntervalMs` amount of\n   * milliseconds, emits the volume passed to it as a `Events.Volume` event.\n   * @param value the volume\n   */\n  private _onVolume(value: number): void {\n    if (value > this._maxValue) {\n      this._maxValue = value;\n    }\n    this._values.push(value);\n    this.emit(InputTest.Events.Volume, value);\n  }\n\n  /**\n   * Warning event handler.\n   * @param warning\n   */\n  private _onWarning(error: DiagnosticError): void {\n    if (this._options.debug) {\n      // tslint:disable-next-line no-console\n      console.warn(error);\n    }\n  }\n\n  /**\n   * Entry point into the input device test. Uses the `MediaStream` that the\n   * object was set up with, and performs a fourier transform on the audio data\n   * using an `AnalyserNode`. The output of the fourier transform are the\n   * relative amplitudes of the frequencies of the audio data. The average of\n   * this data can then be used as an estimate as the average volume of the\n   * entire volume source.\n   *\n   * @event Events.Volume\n   */\n  private async _startTest(): Promise<void> {\n    try {\n      // Try to validate all of the inputs before starting the test.\n      // We perform this check here so if the validation throws, it gets handled\n      // properly as a fatal-error and we still emit a report with that error.\n      const invalidReasons: InvalidityRecord<InputTest.Options> | undefined =\n        await validateOptions<InputTest.Options>(this._options, {\n          deviceId: validateDeviceId,\n          duration: validateTime,\n          volumeEventIntervalMs: validateTime,\n        });\n      if (invalidReasons) {\n        throw new InvalidOptionsError(invalidReasons);\n      }\n\n      if (!this._options.getUserMedia) {\n        throw GetUserMediaUnsupportedError;\n      }\n      this._mediaStream = await this._options.getUserMedia({\n        audio: { deviceId: this._options.deviceId },\n      });\n\n      if (!this._options.enumerateDevices) {\n        throw EnumerateDevicesUnsupportedError;\n      }\n      this._defaultDevices = getDefaultDevices(\n        await this._options.enumerateDevices(),\n      );\n\n      // Only starts the timer after successfully getting devices\n      this._startTime = Date.now();\n\n      if (!this._options.audioContextFactory) {\n        throw AudioContextUnsupportedError;\n      }\n      this._audioContext = new this._options.audioContextFactory();\n\n      const analyser: AnalyserNode = this._audioContext.createAnalyser();\n      analyser.smoothingTimeConstant = 0.4;\n      analyser.fftSize = 64;\n\n      const microphone: MediaStreamAudioSourceNode =\n        this._audioContext.createMediaStreamSource(this._mediaStream);\n      microphone.connect(analyser);\n\n      this._cleanupAudio = (): void => {\n        analyser.disconnect();\n        microphone.disconnect();\n      };\n\n      const frequencyDataBytes: Uint8Array =\n        new Uint8Array(analyser.frequencyBinCount);\n\n      // This function runs every `this._options.reportRate` ms and emits the\n      // current volume of the `MediaStream`.\n      const volumeEvent: () => void = (): void => {\n        if (this._endTime) {\n          return;\n        }\n\n        analyser.getByteFrequencyData(frequencyDataBytes);\n        const volume: number =\n          frequencyDataBytes.reduce(\n            (sum: number, val: number) => sum + val,\n            0,\n          ) / frequencyDataBytes.length;\n        this._onVolume(volume);\n\n        if (Date.now() - this._startTime! > this._options.duration) {\n          this.stop();\n        } else {\n          this._volumeTimeout = setTimeout(\n            volumeEvent,\n            this._options.volumeEventIntervalMs,\n          );\n        }\n      };\n\n      this._volumeTimeout = setTimeout(\n        volumeEvent,\n        this._options.volumeEventIntervalMs,\n      );\n    } catch (error) {\n      if (error instanceof DiagnosticError) {\n        // There is some other fatal error.\n        this._onError(error);\n      } else if (\n        typeof DOMException !== 'undefined' && error instanceof DOMException\n      ) {\n        this._onError(new DiagnosticError(\n          error,\n          'A `DOMException` has occurred.',\n        ));\n      } else if (\n        typeof DOMError !== 'undefined' && error instanceof DOMError\n      ) {\n        this._onError(new DiagnosticError(\n          error,\n          'A `DOMError` has occurred.',\n        ));\n      } else {\n        this._onError(new DiagnosticError(\n          undefined,\n          'Unknown error occurred.',\n        ));\n        this._onWarning(error);\n      }\n      this.stop(false);\n    }\n  }\n}\n\nexport namespace InputTest {\n  /**\n   * Possible events that an `InputTest` might emit. See [[InputTest.on]].\n   */\n  export enum Events {\n    End = 'end',\n    Error = 'error',\n    Volume = 'volume',\n  }\n\n  /**\n   * Represents the report generated from an [[InputTest]].\n   */\n  export interface Report {\n    /**\n     * The device ID used to get a MediaStream from using [getUserMedia](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia).\n     */\n    deviceId: MediaTrackConstraintSet['deviceId'];\n\n    /**\n     * Whether or not the test passed. This is `true` if no errors were detected or if the volumes are not silent.\n     */\n    didPass: boolean;\n\n    /**\n     * Any errors that occurred during the test.\n     */\n    errors: DiagnosticError[];\n\n    /**\n     * The name of the test.\n     */\n    testName: typeof InputTest.testName;\n\n    /**\n     * Time measurements of test run time.\n     */\n    testTiming?: TimeMeasurement;\n\n    /**\n     * The volume levels emitted by the test during its run-time.\n     */\n    values: number[];\n  }\n\n  /**\n   * Options passed to [[InputTest]] constructor.\n   */\n  export interface Options {\n    /**\n     * AudioContext mock to be used during the test.\n     * @private\n     */\n    audioContextFactory?: typeof window.AudioContext;\n\n    /**\n     * Whether or not to log debug statements to the console.\n     * @private\n     */\n    debug?: boolean;\n\n    /**\n     * The device ID to try to get a MediaStream from using [getUserMedia](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia).\n     */\n    deviceId?: MediaTrackConstraintSet['deviceId'];\n\n    /**\n     * Duration of time to run the test in ms.\n     * @default Infinity\n     */\n    duration?: number;\n\n    /**\n     * Used to mock the call to `enumerateDevices`.\n     * @private\n     */\n    enumerateDevices?: typeof navigator.mediaDevices.enumerateDevices;\n\n    /**\n     * Used to mock calls to `getUserMedia`.\n     * @private\n     */\n    getUserMedia?: typeof window.navigator.mediaDevices.getUserMedia;\n\n    /**\n     * The interval between emissions of volume events in milliseconds.\n     * @default 100\n     */\n    volumeEventIntervalMs?: number;\n  }\n\n  /**\n   * Option typing after initialization, so we can have type guarantees.\n   * @private\n   */\n  export type InternalOptions = SubsetRequired<Options, 'duration' | 'volumeEventIntervalMs'>;\n}\n\n/**\n * [[InputTest]] tests audio input capabilities. It serves to help diagnose\n * potential audio device issues that would prevent audio from being recognized\n * in a WebRTC call.\n *\n * ---\n *\n * The [[InputTest]] class is an `EventEmitter` (please see [[InputTest.on]] for\n * events and their details) and helps to diagnose issues by capturing user\n * audio and emitting the volume levels detected in that media.\n * ```ts\n * import { InputTest, testInputDevice } from '@twilio/rtc-diagnostics';\n * const options: InputTest.Options = { ... };\n * // `options` may be left `undefined` to use default option values\n * const inputTest: InputTest = testInputDevice(options);\n * ```\n * Applications can use the volume events emitted by the test to update their UI\n * to show to the user whether or not their media was captured successfully.\n * ```ts\n * inputTest.on(InputTest.Events.Volume, (volume: number) => {\n *   ui.updateVolume(volume); // Update your UI with the volume value here.\n * });\n * ```\n * The test can be normally stopped two ways: allowing the test to time out and\n * stopping the test manually.\n *\n * If the test was allowed to time out, the value of\n * [[InputTest.Report.didPass]] will be determined by the ratio of silent volume\n * values in the captured media.\n *\n * To end the test manually, the application can ask the end-user to confirm\n * that the volume levels it emits are what the end-user expects. If so, the\n * application can call the [[InputTest.stop]] method with `true`. Otherwise,\n * if the audio values are not expected, the application can call\n * [[InputTest.stop]] with `false`.\n * ```ts\n * // The UI should indicate that if the volume values are what the user\n * // expects, they can click this button to pass and stop the test...\n * const volumeCorrectButton = ...;\n * volumeCorrectButton.addEventListener('click', () => {\n *   inputTest.stop(true);\n * });\n *\n * // ...otherwise, if the volume levels are not what they expect, they can\n * // click this.\n * const volumeIncorrectButton = ...;\n * volumeIncorrectButton.addEventListener('click', () => {\n *   inputTest.stop(false);\n * });\n * ```\n * Calling [[InputTest.stop]] will immediately end the test. The value of\n * [[InputTest.Report.didPass]] is determined from the ratio of silent audio\n * levels detected in the user media, but overwritten by passing `false` to\n * [[InputTest.stop]].\n *\n * ---\n *\n * The [[InputTest]] object will always emit a [[InputTest.Report]] with the\n * [[InputTest.Events.End]] event, regardless of the occurrence of errors during\n * the runtime of the test.\n *\n * Fatal errors will immediately end the test and emit a report such that the\n * value of [[InputTest.Report.didPass]] will be `false` and the value of\n * [[InputTest.Report.errors]] will contain the fatal error.\n *\n * Non-fatal errors will not end the test, but will be included in the value of\n * [[InputTest.Report.errors]] upon completion of the test.\n *\n * ---\n *\n * The function [[testInputDevice]] serves as a factory function that accepts\n * [[InputTest.Options]] as its only parameter and will instantiate an\n * [[InputTest]] object with those options.\n * ```ts\n * import { InputTest, testInputDevice } from '@twilio/rtc-diagnostics';\n * const options: InputTest.Options = { ... };\n * const inputTest: InputTest = testInputDevice(options);\n * ```\n *\n * @param options Options to pass to the [[InputTest]] constructor.\n */\nexport function testInputDevice(\n  options?: InputTest.Options,\n): InputTest {\n  return new InputTest(options);\n}\n"]}